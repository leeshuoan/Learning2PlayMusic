// DynamoDB
# assuming store conversations in user info table!
Table <Message>:
partition key = conversationId <string>
sort key = timestamp <string>
attr = author <string>
attr = messageBody <string> 


conversationId = teacher (always in front) + student
eg. 
student = abc
teacher =  123
convId = abc+123

//IAM
add in policy to LambdaDynamoDBRole role to allow getItem to "Chat" ARN




Steps for a chat System
1. View contact list on render 
-> if student, view teachers
[GET]/chat/get_teachers?user_name={student_userID}

-> if teacher, view all existing conversations
[GET]/chat/get_chats?user_name={teacher_userID}
## need to clarify if admin needs the chat function and what should be their chat for?

2. On click of a specific contact, load conversation history
[GET]chat/read

3. After typing message in chat box, can send it to the user
[POST]chat/send
request body = 
{
  "conversationId": "8cf0cd07-b89c-4140-88f0-327dbe720754+e67a3c45-e06e-4ca6-b57a-e149947b0223",
  "author": "8cf0cd07-b89c-4140-88f0-327dbe720754",
  "messageBody": "i am the student!"
}

( in order to receive it instantly, might need web socket API on APIGW)
If we omit the websocket portion, users will have to manually refresh the chat window or implement polling mechanisms to fetch new messages periodically. 
This can be a suboptimal user experience, especially for real-time chat applications where users expect instant feedback. 
WebSocket connections allow for bidirectional communication between clients and servers, enabling real-time updates and a smoother user experience.

High level steps for real-time chat:
https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api.html
Set up API Gateway to handle WebSocket connections and route them to a Lambda function. 
In the Lambda function, handle the CONNECT, DISCONNECT, and MESSAGE events that are sent over the WebSocket connection. 
When a user connects, store the connection ID in a data store (such as DynamoDB) so that you can later send messages to that user. 
When a user disconnects, remove their connection ID from the data store.
When a user sends a message, broadcast it to all connected users by iterating through the connection IDs in the data store and sending the message to each connection.
On the front-end client, open a WebSocket connection to the API Gateway endpoint and listen for incoming messages. 
When a message arrives, update the UI to show the message to the user.

use AppSync to create GraphQL APIs for consumers to subscribe to real-time updates from the other chat party

